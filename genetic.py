#/usr/bin/env python
# encoding: UTF-8


# This program is supposed to find a bitstring which only consists of 1's,
# starting with a random 'population' of bitstrings

import math
import random


POP_SIZE    = 100       # constant size of our population
STRING_LEN  =  32       # length of every string
NUM_PARENTS =  10       # number of parents which get selected each generation
NUM_OFFSPR  =  10       # number of offsprings generated by each parent



# generates a pseudo-random bitstring of length STRING_LEN
def random_bitstring():
	bitstr = ""

	for _ in range(STRING_LEN):
		bit     = round(random.random())
		bitstr += repr(bit)

	return bitstr



# returns the occurences of '1' and thus the 'fitness' in the given bitstring
def get_bitstr_fitness(bitstr):

	return bitstr.count('1')



# returns a list with all the fitness scores of a given population
def get_population_fitness(population):
	scores = []

	for i in range(len(population)):
		bitstr_score = get_bitstr_fitness(population[i])
		scores.append(bitstr_score)

	return scores



# returns the index of the maximum score and therefore the index of the
# fittest parent in our generation of our population
def get_fittest(scores):
	fittest_score = max(scores)
	fittest_index = scores.index(fittest_score)

	return fittest_index



# given a parent bitstring, generate a single offspring by chosing a random
# bit of the parent string and flipping it
def generate_offspring(parent):
	offspring = list(parent)
	flip_pos  = random.randint(0, STRING_LEN-1)

	if (parent[flip_pos] == '1'):
		offspring[flip_pos] = '0'
	else:
		offspring[flip_pos] = '1'

	return "".join(offspring)




population   = []
generation   = 0

# Initial population of random bitstrings
for _ in range(POP_SIZE):
	candidate = random_bitstring()
	population.append(candidate)


while True:
	generation = generation + 1
	scores     = get_population_fitness(population)

	# check for winner
	if (max(scores) == STRING_LEN):
		winner_index = scores.index(STRING_LEN)
		winner_str   = population[winner_index]

		print("Winner: ", winner_str)
		print("It took ", generation, " generations")

		break

	parents = []

	# select the fittest future parents of our current generation
	for _ in range(NUM_PARENTS):
		parent_index = get_fittest(scores)
		parents.append(population[parent_index])
		scores[parent_index] = -1


	offsprings = []

	# generate new offsprings of each parent
	for i in range(NUM_PARENTS):
		for j in range(NUM_OFFSPR):
			offspring = generate_offspring(parents[i])
			offsprings.append(offspring)

	# construct new generation of our population by only using the
	# selected parents and their offsprings
	population = []

	for i in range(len(offsprings)):
		population.append(offsprings[i])

	for i in range(len(parents)):
		population.append(parents[i])
